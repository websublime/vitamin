{"version":3,"file":"CustomMarkdownEmitter.js","sourceRoot":"","sources":["../../src/markdown/CustomMarkdownEmitter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport colors from 'colors';\n\nimport { DocNode, DocLinkTag, StringBuilder } from '@microsoft/tsdoc';\nimport { ApiModel, IResolveDeclarationReferenceResult, ApiItem } from '@microsoft/api-extractor-model';\n\nimport { CustomDocNodeKind } from '../nodes/CustomDocNodeKind';\nimport { DocHeading } from '../nodes/DocHeading';\nimport { DocNoteBox } from '../nodes/DocNoteBox';\nimport { DocTable } from '../nodes/DocTable';\nimport { DocTableCell } from '../nodes/DocTableCell';\nimport { DocEmphasisSpan } from '../nodes/DocEmphasisSpan';\nimport { MarkdownEmitter, IMarkdownEmitterContext, IMarkdownEmitterOptions } from './MarkdownEmitter';\nimport { IndentedWriter } from '../utils/IndentedWriter';\n\nexport interface ICustomMarkdownEmitterOptions extends IMarkdownEmitterOptions {\n  contextApiItem: ApiItem | undefined;\n\n  onGetFilenameForApiItem: (apiItem: ApiItem) => string | undefined;\n}\n\nexport class CustomMarkdownEmitter extends MarkdownEmitter {\n  private _apiModel: ApiModel;\n\n  public constructor(apiModel: ApiModel) {\n    super();\n\n    this._apiModel = apiModel;\n  }\n\n  public emit(\n    stringBuilder: StringBuilder,\n    docNode: DocNode,\n    options: ICustomMarkdownEmitterOptions\n  ): string {\n    return super.emit(stringBuilder, docNode, options);\n  }\n\n  /** @override */\n  protected writeNode(docNode: DocNode, context: IMarkdownEmitterContext, docNodeSiblings: boolean): void {\n    const writer: IndentedWriter = context.writer;\n\n    switch (docNode.kind) {\n      case CustomDocNodeKind.Heading: {\n        const docHeading: DocHeading = docNode as DocHeading;\n        writer.ensureSkippedLine();\n\n        let prefix: string;\n        switch (docHeading.level) {\n          case 1:\n            prefix = '##';\n            break;\n          case 2:\n            prefix = '###';\n            break;\n          case 3:\n            prefix = '###';\n            break;\n          default:\n            prefix = '####';\n        }\n\n        writer.writeLine(prefix + ' ' + this.getEscapedText(docHeading.title));\n        writer.writeLine();\n        break;\n      }\n      case CustomDocNodeKind.NoteBox: {\n        const docNoteBox: DocNoteBox = docNode as DocNoteBox;\n        writer.ensureNewLine();\n\n        writer.increaseIndent('> ');\n\n        this.writeNode(docNoteBox.content, context, false);\n        writer.ensureNewLine();\n\n        writer.decreaseIndent();\n\n        writer.writeLine();\n        break;\n      }\n      case CustomDocNodeKind.Table: {\n        const docTable: DocTable = docNode as DocTable;\n        // GitHub's markdown renderer chokes on tables that don't have a blank line above them,\n        // whereas VS Code's renderer is totally fine with it.\n        writer.ensureSkippedLine();\n\n        context.insideTable = true;\n\n        // Markdown table rows can have inconsistent cell counts.  Size the table based on the longest row.\n        let columnCount: number = 0;\n        if (docTable.header) {\n          columnCount = docTable.header.cells.length;\n        }\n        for (const row of docTable.rows) {\n          if (row.cells.length > columnCount) {\n            columnCount = row.cells.length;\n          }\n        }\n\n        // write the table header (which is required by Markdown)\n        writer.write('| ');\n        for (let i: number = 0; i < columnCount; ++i) {\n          writer.write(' ');\n          if (docTable.header) {\n            const cell: DocTableCell | undefined = docTable.header.cells[i];\n            if (cell) {\n              this.writeNode(cell.content, context, false);\n            }\n          }\n          writer.write(' |');\n        }\n        writer.writeLine();\n\n        // write the divider\n        writer.write('| ');\n        for (let i: number = 0; i < columnCount; ++i) {\n          writer.write(' --- |');\n        }\n        writer.writeLine();\n\n        for (const row of docTable.rows) {\n          writer.write('| ');\n          for (const cell of row.cells) {\n            writer.write(' ');\n            this.writeNode(cell.content, context, false);\n            writer.write(' |');\n          }\n          writer.writeLine();\n        }\n        writer.writeLine();\n\n        context.insideTable = false;\n\n        break;\n      }\n      case CustomDocNodeKind.EmphasisSpan: {\n        const docEmphasisSpan: DocEmphasisSpan = docNode as DocEmphasisSpan;\n        const oldBold: boolean = context.boldRequested;\n        const oldItalic: boolean = context.italicRequested;\n        context.boldRequested = docEmphasisSpan.bold;\n        context.italicRequested = docEmphasisSpan.italic;\n        this.writeNodes(docEmphasisSpan.nodes, context);\n        context.boldRequested = oldBold;\n        context.italicRequested = oldItalic;\n        break;\n      }\n      default:\n        super.writeNode(docNode, context, docNodeSiblings);\n    }\n  }\n\n  /** @override */\n  protected writeLinkTagWithCodeDestination(\n    docLinkTag: DocLinkTag,\n    context: IMarkdownEmitterContext<ICustomMarkdownEmitterOptions>\n  ): void {\n    const options: ICustomMarkdownEmitterOptions = context.options;\n\n    const result: IResolveDeclarationReferenceResult = this._apiModel.resolveDeclarationReference(\n      docLinkTag.codeDestination!,\n      options.contextApiItem\n    );\n\n    if (result.resolvedApiItem) {\n      const filename: string | undefined = options.onGetFilenameForApiItem(result.resolvedApiItem);\n\n      if (filename) {\n        let linkText: string = docLinkTag.linkText || '';\n        if (linkText.length === 0) {\n          // Generate a name such as Namespace1.Namespace2.MyClass.myMethod()\n          linkText = result.resolvedApiItem.getScopedNameWithinPackage();\n        }\n        if (linkText.length > 0) {\n          const encodedLinkText: string = this.getEscapedText(linkText.replace(/\\s+/g, ' '));\n\n          context.writer.write('[');\n          context.writer.write(encodedLinkText);\n          context.writer.write(`](${filename!})`);\n        } else {\n          console.log(colors.yellow('WARNING: Unable to determine link text'));\n        }\n      }\n    } else if (result.errorMessage) {\n      console.log(\n        colors.yellow(\n          `WARNING: Unable to resolve reference \"${docLinkTag.codeDestination!.emitAsTsdoc()}\": ` +\n            result.errorMessage\n        )\n      );\n    }\n  }\n}\n"]}